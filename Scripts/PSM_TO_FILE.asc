# Script that generates files for importing models on the specified Platform
# DEBUG (ext coupling) SHORTCUT
# PSM_TO_FILE

### Procedure to export PSM to specific platform
    ## 1. Get the current open model
    ## 2. Select path to export files
    ## 3. Execute platform specific procedure
PROCEDURE global PSM_TO_FILE
{
    ## 1.
    # Get current model
    CC "Modeling" GET_ACT_MODEL
    SET modelID:(modelid)
    IF (modelID = -1) {
        CC "AdoScript" WARNINGBOX ("Select a PSM model to proceed.")
        EXIT
    }
    # Check if current model is a PSM
    CC "Core" GET_ATTR_VAL objid:(modelID) attrname:("Model Type")
    IF (val != "PSM") {
        CC "AdoScript" WARNINGBOX ("Select a PSM model to proceed.")
        EXIT
    }

    ## 2.
    # Select the path to save files
    CC "AdoScript" DIRECTORY_DIALOG
    IF (endbutton != "ok") {
        EXIT
    }

    ## 3.
    # Get platform name
    CC "Core" GET_ATTR_VAL objid:(modelID) attrname:("Platform")
    SET platform:(val)
    # Choose export function
    IF (platform = "ThingsBoard") {
        THINGSBOARD modelID:(modelID) path:(path)
    } ELSIF (platform = "Losant") {
        LOSANT modelID:(modelID) path:(path)
    } ELSIF (platform = "Azure") {
        AZURE modelID:(modelID) path:(path)
    } ELSE {
        CC "AdoScript" WARNINGBOX ("Platform not supported.")
        EXIT
    }
}

PROCEDURE global AZURE 
modelID:integer # Source model's id
path:string # Path where to save files
{

	CC "Core" GET_MODEL_MODELTYPE modelid:(modelID)
    IF( modeltype = "IoT Logic") {
        AZURE_LOGIC path:(path)
        EXIT
    }

    CC "AdoScript" WARNINGBOX("Please ensure that there are no accented letters on devices, device's operations or attributes names.\nThey may cause import failure on Azure!")

    # Application name and device template name are used for the id buildings
    SET applicationURL: ""

    # Take all the model devices
    CC "AdoScript" EDITFIELD title:"Azure's Application subdomain" caption:"Enter Azure's Application subdomain:" text:"myazureapplication"
    IF (ecode != 0) {# if "ok" button is not clicked, something went wrong
        EXIT
    }
    SET applicationURL:(text)

    SET path:(path + "\\" + applicationURL)
    CC "AdoScript" DIR_CREATE path:(path)

    CC "Core" LOAD_MODEL modelid:(modelID)

    # for each device return a json file with the device's capabilities
    CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("device")

    # iterate over the devices, for each device create a <deviceName>_capabilities.json file
    FOR device in:(objids) {
        
        # The json file starts with the [] so we need to write first an array of objects (in this case, with only one "primary"-object)
        SET container:({})

        SETL primaryObject:(map()) # primaryObject: the only global object inserted into the json file, the only element of the "container" array 

        SET contents:({})   # array "contents" with many "capability" objects as the number of the device capabilities' 

        # Get the device's name
        CC "Core" GET_ATTR_VAL objid:(VAL device) attrname:("name")
        SET deviceName:(replall(val, " ", "")) # delete every space in between the device's name
        
        # fill "contents" array
        SET_CAPABILITIES contents:contents device:(VAL device)

        # @id & @type
        SETL primaryObject:({
            "@id":"dtmi:"+applicationURL+":"+deviceName+"_"+"123"+";"+"1",
            "@type":"Interface",
            "contents": contents,
            "displayName": {
                "en": deviceName
            },
            "@context":({
                "dtmi:iotcentral:context;2",   # version 2 by default: last number means version
                "dtmi:dtdl:context;2"
            })
        })

        SET filePath:(path + "\\"+deviceName+"_capabilities.json")

        # everything inside container (Azure json file format...)
        SET container:({primaryObject})

        #  final instructions
        SETL primaryObject:(lam_toJson(container))
        CC "AdoScript" FWRITE file:(filePath) text:(primaryObject)
    }    
}

# fill "contents" array on .json files generated from each device
PROCEDURE global SET_CAPABILITIES
contents:reference
device:integer
{
    # Get all the objects linked to this object (intially the object is a "device" object)
    CC "Core" GET_CONNECTORS objid:(device) out
    FOR connector in:(objids) {
        CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL connector)
        CC "Core" GET_CLASS_ID objid:(toobjid)
        CC "Core" GET_CLASS_NAME classid:(classid)
        # if it has "attribute", "Device Operation" or "location" objects linked to it, fill "contents" array (the one with all the capabilities)
        IF( classname = "attribute") {
            # Azure device template's capabilities of type "Telemetry": find these informations inside "Attribute" objects
            CC "Core" GET_ATTR_VAL objid:(toobjid) attrname:("name")
            SETL attributeName:(replall(val, " ", ""))
            CC "Core" GET_ATTR_VAL objid:(toobjid) attrname:("psm_type")
            SETL attributePsmType:(val)
            IF(attributePsmType="") {
                CC "AdoScript" WARNINGBOX ("psm_type not selected, "+attributeName+" .json file creation was aborted.\nObject id: "+ STR toobjid)
                NEXT
            }
            SETL attributeDescription:""
            CC "Core" GET_ATTR_VAL objid:(toobjid) attrname:("description")
            IF(val!="") {
                SETL attributeDescription:(val)
            }
            SETL newCapability:({
                "@id": "dtmi:"+applicationURL+":"+deviceName+"_123:"+attributeName+";1",
                "@type":({
                    "Telemetry",
                    "NumberValue",
                    attributePsmType
                }),
                "description":({
                    "en": attributeDescription
                }),
                "name": attributeName
            })
            SETL newCapability["name"]:(attributeName)
            SET_CAPABILITY_SCHEMA_AND_UNIT capability:newCapability attribute:toobjid
            SET nothing:(aappend(contents, newCapability))

        } ELSIF ( classname="Device Operation") {
            # Azure device template's capabilities of type "Command": find these informations inside "Device Operation" objects
            CC "Core" GET_ATTR_VAL objid:(toobjid) attrname:("name")
            SETL commandName:(replall(val, " ", ""))
            CC "Core" GET_ATTR_VAL objid:(toobjid) attrname:("description")
            SETL deviceOperationDescription:(val)

            SETL newCapability:({
                "@id":"dtmi:"+applicationURL+":"+deviceName+"_123:"+commandName+";1",
                "@type": "Command",
                "commandType": "synchronous",
                "description": ({
                    "en": deviceOperationDescription
                }),
                "name": commandName
            })

            SET nothing:(aappend(contents, newCapability))
        } ELSIF ( classname="location") {
            CC "Core" GET_ATTR_VAL objid:(toobjid) attrname:("description")
            SETL description:(val)
            SETL newCapability:({
                "@id": "dtmi:"+applicationURL+":"+deviceName+"_123:locationProperty;1",
                "@type":({
                    "Property",
                    "Location"
                }),
                "description":({
                    "en": description
                }),
                "name": "locationProperty",
                "schema": "geopoint"
            })
            SET nothing:(aappend(contents, newCapability))
        }
        # iterate over the "deeper" objects:
        #
        #    maybe some "attribute", "Device Operation" or "location" objects are not linked directly to the "device" object
        SET_CAPABILITIES contents:contents device:(toobjid)
    } 
}

# each telemetry has its own schema and unit ( it's better to work on each capability instead of working globally )
# it will be easier to insert more details in the future
PROCEDURE global SET_CAPABILITY_SCHEMA_AND_UNIT
capability:reference
attribute:reference
{
    CC "Core" GET_ATTR_VAL objid:(attribute) attrname:("psm_type")
    SETL specAttr:(val)

    SETL attributeSpecRecs:({})
    GET_SPECIFICATION_RECORDS objid:(attribute) specRecs:attributeSpecRecs

    # Get specification attributes
    IF(specAttr = "Acceleration") {
        SET capability["schema"]:"double"
        SET capability["unit"]:("metrePerSecondSquared")
        SET capability["maxValue"]:(VAL attributeSpecRecs[0])

    } ELSIF (specAttr = "Distance") {
        SET capability["schema"]:"integer"
        SET capability["unit"]:("metre")
        SET capability["maxValue"]:(VAL attributeSpecRecs[0])

    } ELSIF ( specAttr = "Humidity") {
        SET capability["schema"]:"double"

    } ELSIF ( specAttr = "Temperature") {
        SET capability["schema"]:"double"
        SET capability["unit"]:(attributeSpecRecs[0])

    } ELSIF ( specAttr = "Force") {
        SET capability["schema"]:"double"
        SET capability["unit"]:(attributeSpecRecs[0])

    } ELSIF ( specAttr = "Mass") {
        SET capability["schema"]:"double"
        SET capability["unit"]:(attributeSpecRecs[0])

    } ELSIF ( specAttr = "Area") {
        SET capability["schema"]:"double"
        SET capability["unit"]:(attributeSpecRecs[0])

    } ELSIF ( specAttr = "Pressure") {
        SET capability["schema"]:"double"
        SET capability["unit"]:(attributeSpecRecs[0])
    }
}


# Export all the "blue objects" (pubsub_out, datastream_out, storage, request_out, notification) in a json file.
# this creates n .json files as n "blue objects" present in this model

# todo rivedere questo : each file should be imported in a new empty Logic application (in portal.azure.com obviously...)

# The rules defined in <yourapplication>.azureiotcentral.com have some actions linked to the LogicApp in portal.azure.com 
# each rule has its own application which define the actions to be executed when the rule is triggered (!!!!!!!!)

#AZURE_LOGIC path:("C:\\evvai")

PROCEDURE global AZURE_LOGIC
path:string
{
    # todo accomedare un po di roba
    #CC "AdoScript" EDITFIELD title:"Azure's Logic Application name" caption:"Enter Azure's Logic Application name:" text:"azurelogicapplication"
    #IF (ecode != 0) {# if "ok" button is not clicked, something went wrong
    #    EXIT
    #}
    #SET applicationName:(text)
    SET newLogicAppName:("uploadiamotutto")

    #SET path:(path + "\\" + applicationName)
    #CC "AdoScript" DIR_CREATE path:(path)

    #CC "AdoScript" EDITFIELD title:"Azure's Logic main resource group name" caption:"Enter Azure's Logic main resource group name:" text:"resourcegroupname"
    #IF (ecode != 0) {# if "ok" button is not clicked, something went wrong
    #    EXIT
    #}
    #SET mainResourceGroupName:(text) todo accomedare
    SET mainResourceGroupName:("nuovoResourceGroup")

    #CC "AdoScript" EDITFIELD title:"Azure's Logic main resource group name" caption:"Enter Azure's Logic main resource group name:" text:"resourcegroupname"
    #IF (ecode != 0) {# if "ok" button is not clicked, something went wrong
    #    EXIT
    #}
    #SET subscriptionId:(text) todo accomedare
    SET subscriptionId:("24a9446b-8b9b-42af-85ab-6476a6ad7cfc")

    # Todo questo decommentarlo
    #CC "AdoScript" EDITFIELD title:"Azure iot central application id" caption:"Enter Azure iot central application id:" text:"my-azure-iot-central-id"
    #IF (ecode != 0) {# if "ok" button is not clicked, something went wrong
    #    EXIT
    #}
    SETL applicationId: "ac37aa3e-5478-4122-9bf7-6294e993e353" # (text) todo accomedare
    
    # todo magari invece che controllare se ci sono piu connessioni api ad azure iot central o sendmessage o mongodb --> WARNINGBOX con scritto (make sure che ce sta un solo connessione api di ste cose)
    # forse in realtà manco ce sta bisogno: se ce n'è piu di una prendo la prima, che prob c'è (alla peggio ce n'è 2 e viene eliminata la prima)

    # per ora prendere per buona questa rule qua TODO alla fine accomedareq
    SETL ruleId:"0d06609f-85f7-465f-a020-9b4e03f74996"


    GET_SPECIFICATIONS platform: ("Azure") specs: specs

    SET_PARAMETERS_PRESETS


    CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("storage")
    SETL storages:(objids)
    CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("data_stream_out")
    SETL dsouts:(objids)
    CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("pubsub_out")
    SETL psouts:(objids)
    CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("request_out")
    SETL requests:(objids)
    
    FOR storage in:(storages) {
        # if a "blue object" has one or more outgoing connectors it could create a cycle (or reach another blue object)
        CC "Core" GET_CONNECTORS objid:(VAL storage) out
        FOR connid in:(objids) {
            CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL connid)
            CC "Core" GET_OBJ_NAME objid:(toobjid)
            CC "AdoScript" INFOBOX("toobjid name " +objname )

        }
    }
    
    #   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    # todo NEW STUFF
    # CYCLES_ANALYZE result:result toEsclude: <array Of Objid To Esclude From Single JsonFile Production> !!!!!!!!!!!!!
    # then iterate over all objids for each "blue object" excluding all the objids found in the CYCLE_ANALYZE procedure (ESCLUDO, se c'è un ciclo, sia l oggetto blu di partenza che gli intermedi/di arrivo)
    # e quindi creo un preset json a sé

    #   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    # todo if objids its not empty --> warning box: "make sure a single api connection and a single  mongo db connection are in your Azure portal resource group"
    
    # 1. for every single "blue object" create a specific .json
    # storage object
    FOR storage in:(storages) {
        CC "Core" GET_ATTR_VAL objid:(VAL storage) attrname:("psm_type")
        IF( val = "") {
            NEXT
        }
    
        SETL storageTypeSelected:(val)

        CC "Core" GET_ATTR_VAL objid:(VAL storage) attrname:("name")
        SETL storageName:(val)

        SETL stoargeSpecRecs:({})
        GET_SPECIFICATION_RECORDS objid:(VAL storage) specRecs:stoargeSpecRecs

        IF(storageTypeSelected="Insert_Document") {
            SETL insertDocumentAction:(map())
            GET_INSERT_DOCUMENT_ACTION insertDocumentAction:insertDocumentAction runAfter:(map()) stoargeSpecRecs:(stoargeSpecRecs)
            # if the map is empty some important fields in "storageSpecRecs" are empty 
            IF(insertDocumentAction.empty = 1) {
                NEXT
            }
            SETL defaultTrigger:(map())
            DEFAULT_TRIGGER triggers:defaultTrigger ruleId:(stoargeSpecRecs[4])
            CREATE_NEW_FILE actions:(insertDocumentAction) triggers:(defaultTrigger) parametersSection:(mongoDB_AzureIotCentralParameterSection) parameters:(mongoDB_AzureIotCentralParameter) objectName:(storageName)

        } ELSE {
            SETL createOrUpdateDeviceAction:(map())
            GET_CREATE_OR_UPDATE_DEVICE_ACTION createOrUpdateDeviceAction:createOrUpdateDeviceAction runAfter:(map()) stoargeSpecRecs:(stoargeSpecRecs)
            # if the map is empty some important fields in "storageSpecRecs" are empty 
            IF(createOrUpdateDeviceAction.empty = 1) {
                NEXT
            }
            SETL defaultTrigger:(map())
            DEFAULT_TRIGGER triggers:defaultTrigger ruleId:(stoargeSpecRecs[2])
            CREATE_NEW_FILE actions:(createOrUpdateDeviceAction) triggers:(defaultTrigger) parametersSection:(onlyAzureIotCentralParameterSection) parameters:(onlyAzureIotCentralParameter) objectName:(storageName)
        } 
    }

    # datastream_out object
    FOR dataStreamOut in:(dsouts) {
        CC "Core" GET_ATTR_VAL objid:(VAL dataStreamOut) attrname:("psm_type")
        IF( val = "") {
            NEXT
        }

        CC "Core" GET_ATTR_VAL objid:(VAL dataStreamOut) attrname:("name")
        SETL dataStreamOutName:(val)

        SETL dataStreamOutSpecRecs:({})
        GET_SPECIFICATION_RECORDS objid:(VAL dataStreamOut) specRecs:dataStreamOutSpecRecs

        SETL runADeviceCommandAction:(map())
        GET_RUN_A_DEVICE_COMMAND_ACTION runADeviceCommandAction:runADeviceCommandAction runAfter:(map()) dataStreamOutSpecRecs:(dataStreamOutSpecRecs)
        IF(runADeviceCommandAction.empty = 1) {
            NEXT
        }
        
        SETL defaultTrigger:(map())
        DEFAULT_TRIGGER triggers:defaultTrigger ruleId:(dataStreamOutSpecRecs[2])
        CREATE_NEW_FILE actions:(runADeviceCommandAction) triggers:(defaultTrigger) parametersSection:(onlyAzureIotCentralParameterSection) parameters:(onlyAzureIotCentralParameter) objectName:(dataStreamOutName)
    }

    # pubsub_out object todo
    FOR pubsubOut in:(psouts) {
        CC "Core" GET_ATTR_VAL objid:(VAL pubsubOut) attrname:("psm_type")
        IF( val = "") {
            NEXT
        }

        CC "Core" GET_ATTR_VAL objid:(VAL pubsubOut) attrname:("name")
        SETL pubsubOutName:(val)

        SETL pubsubOutSpecRecs:({})
        GET_SPECIFICATION_RECORDS objid:(VAL pubsubOut) specRecs:pubsubOutSpecRecs
        
        SETL sendMessageAction:(map())
        GET_SEND_MESSAGE_ACTION sendMessageAction:sendMessageAction runAfter:(map()) pubsubOutSpecRecs:(pubsubOutSpecRecs)
        IF(sendMessageAction.empty = 1) {
            NEXT
        }
        
        SETL defaultTrigger:(map())
        DEFAULT_TRIGGER triggers:defaultTrigger ruleId:(dataStreamOutSpecRecs[2])
        CREATE_NEW_FILE actions:(sendMessageAction) triggers:(defaultTrigger) parametersSection:(serviceBus_AzureIotCentralParameterSection) parameters:(serviceBus_AzureIotCentralParameter) objectName:(pubsubOutName)     

    }

    # request_out object
    FOR requestOut in:(requests) {
        CC "Core" GET_ATTR_VAL objid:(VAL requestOut) attrname:("psm_type")
        # parameters exception handling
        IF( val = "") {
            CC "AdoScript" WARNINGBOX ("psm_type not selected, "+requestOutName+" .json file creation was aborted.")
            NEXT
        }
        SETL httpMethod:(val)

        CC "Core" GET_ATTR_VAL objid:(VAL requestOut) attrname:("name")
        SETL requestOutName:(val)

        SETL requestOutSpecRecs:({})
        GET_SPECIFICATION_RECORDS objid:(VAL requestOut) specRecs:requestOutSpecRecs

        SET dummy:(aappend(requestOutSpecRecs, httpMethod))
        
        SETL httpAction:(map())
        GET_HTTP_ACTION httpAction:httpAction runAfter:(map()) requestOutSpecRecs:(requestOutSpecRecs) 

        IF(httpAction.empty = 1) {
            NEXT
        }
        SETL defaultTrigger:(map())
        DEFAULT_TRIGGER triggers:defaultTrigger ruleId:(requestOutSpecRecs[4])
        CREATE_NEW_FILE actions:(httpAction) triggers:(defaultTrigger) parametersSection:(onlyAzureIotCentralParameterSection) parameters:(onlyAzureIotCentralParameter) objectName:(requestOutName)
    }
} 


# AZURE LOGIC APP --- Main .json structure, flexible structure, todo in future: could be more and more accurated for each detail
PROCEDURE global CREATE_NEW_FILE
actions:map   # actions to be inserted
triggers:map
parametersSection:map
parameters:map
objectName:string
{   
    SETL finalObject:({
        "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
        "contentVersion": "1.0.0.0",
        "parameters": parametersSection,
        "variables": map(),   # forse questo in futuro potrà essere cambiato
        "resources": 
            ({({
                "type": "Microsoft.Logic/workflows",
                "apiVersion": "2017-07-01",
                "name": "[parameters('workflows_"+newLogicAppName+"_name')]",
                "location": "francesouth",
                "tags": {
                    "ms-resource-usage": "azure-cloud-shell"
                },
                "properties": {
                    "state": "Enabled",
                    "definition": {
                        "$schema": "https://schema.management.azure.com/providers/Microsoft.Logic/schemas/2016-06-01/workflowdefinition.json#",
                        "contentVersion": "1.0.0.0",
                        "parameters": {
                            "$connections": {
                                "defaultValue": map(),
                                "type": "Object"
                            }
                        },
                        "triggers": triggers,
                        "actions": actions,
                        "outputs": map()
                    },
                    "parameters": {
                        "$connections": {
                            "value": parameters
                        }
                    }
                }
            })})
    })
            

    # 3. fill the new .json with the json structure informations and this model parameters
    SETL primaryObject:(lam_toJson(finalObject))

    #SET filePath:(path + "\\"+applicationName+".json")
    #CC "AdoScript" FWRITE file:(filePath) text:(primaryObject)
    CC "AdoScript" FWRITE file:("C:\\evvai\\"+objectName+".json") text:(primaryObject) # todo accomedare
}


# AZURE LOGIC APP ---
# todo: maybe in future there will be the opportunity to have multiple triggers (at the same time), for now it's inconvenient or (at least as I understood) only with
# time recurrency (ex: each 3 minutes do this)  
PROCEDURE global DEFAULT_TRIGGER
triggers:reference   # output reference
ruleId:string
{
    SETL triggers:({
            "When_a_rule_is_fired": {
                "type": "ApiConnectionWebhook",
                "inputs": {
                    "body": {
                        "rule": ruleId,
                        "url": "@{listCallbackUrl()}"
                    },
                    "host": {
                        "connection": {
                            "name": "@parameters('$connections')['azureiotcentral']['connectionId']"
                        }
                    },
                    "path": "/api/preview/_internal/workflow/triggers",
                    "queries": {
                        "application": applicationId    # initialized at the start of the file
                    }
                }
            }
    })
}

# AZURE LOGIC APP --- set useful parameters and parameters section for json files production.
#   put these parameters in the final structure, take a look at "CREATE_NEW_FILE"
PROCEDURE global SET_PARAMETERS_PRESETS
{
    SETG allParameters:({
        "azureiotcentral": {
            "connectionId": "[parameters('connections_azureiotcentral_externalid')]",
            "connectionName": "azureiotcentral",
            "id": "/subscriptions/"+subscriptionId+"/providers/Microsoft.Web/locations/francesouth/managedApis/azureiotcentral"
        },
        "mongodb": {
            "connectionId": "/subscriptions/"+subscriptionId+"/resourceGroups/nuovoResourceGroup/providers/Microsoft.Web/connections/mongodb",
            "connectionName": "mongodb",
            "id": "/subscriptions/"+subscriptionId+"/providers/Microsoft.Web/locations/francesouth/managedApis/mongodb"
        },
        "servicebus": {
            "connectionId": "/subscriptions/"+subscriptionId+"/resourceGroups/nuovoResourceGroup/providers/Microsoft.Web/connections/servicebus",
            "connectionName": "servicebus",
            "id": "/subscriptions/"+subscriptionId+"/providers/Microsoft.Web/locations/francesouth/managedApis/servicebus"
        }
    })

    SETG allParametersSection:({
        "workflows_"+newLogicAppName+"_name": {
            "defaultValue": newLogicAppName,
            "type": "String"
        },
        "connections_azureiotcentral_externalid": {
            "defaultValue": "/subscriptions/"+subscriptionId+"/resourceGroups/"+mainResourceGroupName+"/providers/Microsoft.Web/connections/azureiotcentral",
            "type": "String"
        },
        "connections_mongodb_externalid": {
            "defaultValue": "/subscriptions/"+subscriptionId+"/resourceGroups/nuovoResourceGroup/providers/Microsoft.Web/connections/mongodb",
            "type": "String"
        },
        "connections_servicebus_externalid": {
            "defaultValue": "/subscriptions/"+subscriptionId+"/resourceGroups/nuovoResourceGroup/providers/Microsoft.Web/connections/servicebus",
            "type": "String"
        }
    })

    # todo fare si che a questi due (parameter e section) ci si possa aggiungere altra roba, così può funzicare(?)
    # permanent api connection... the one which permits "when_a_rule_is_fired" todo controllare in futuro se è stata creata più di una connessione
    SETG onlyAzureIotCentralParameter:({
        "azureiotcentral": {
            "connectionId": "[parameters('connections_azureiotcentral_externalid')]",
            "connectionName": "azureiotcentral",
            "id": "/subscriptions/"+subscriptionId+"/providers/Microsoft.Web/locations/francesouth/managedApis/azureiotcentral"
        }
    })

    # TODO passare alla CREATE_NEW_FILE i parametri (le mappe) già complete
    SETG onlyAzureIotCentralParameterSection:({
        "workflows_"+newLogicAppName+"_name": {
            "defaultValue": newLogicAppName,                    # questa parte è uguale per ogni json
            "type": "String"
        },
        "connections_azureiotcentral_externalid": {
            "defaultValue": "/subscriptions/"+subscriptionId+"/resourceGroups/"+mainResourceGroupName+"/providers/Microsoft.Web/connections/azureiotcentral",
            "type": "String"
        }
    })

    SETG serviceBus_AzureIotCentralParameter:({
        "azureiotcentral": {
            "connectionId": "[parameters('connections_azureiotcentral_externalid')]",
            "connectionName": "azureiotcentral",
            "id": "/subscriptions/"+subscriptionId+"/providers/Microsoft.Web/locations/francesouth/managedApis/azureiotcentral"
        },
        "servicebus": {
            "connectionId": "[parameters('connections_servicebus_externalid')]",
            "connectionName": "servicebus",
            "id": "/subscriptions/"+subscriptionId+"/providers/Microsoft.Web/locations/francesouth/managedApis/servicebus"
        }
    })

    SETG serviceBus_AzureIotCentralParameterSection:({
        "workflows_"+newLogicAppName+"_name": {
            "defaultValue": newLogicAppName,                    # questa parte è uguale per ogni json
            "type": "String"
        },
        "connections_azureiotcentral_externalid": {
            "defaultValue": "/subscriptions/"+subscriptionId+"/resourceGroups/"+mainResourceGroupName+"/providers/Microsoft.Web/connections/azureiotcentral",
            "type": "String"
        },
        "connections_servicebus_externalid": {
            "defaultValue": "/subscriptions/"+subscriptionId+"/resourceGroups/nuovoResourceGroup/providers/Microsoft.Web/connections/servicebus",
            "type": "String"
        }
    })

    SETG mongoDB_AzureIotCentralParameter:({
        "azureiotcentral": {
            "connectionId": "[parameters('connections_azureiotcentral_externalid')]",
            "connectionName": "azureiotcentral",
            "id": "/subscriptions/"+subscriptionId+"/providers/Microsoft.Web/locations/francesouth/managedApis/azureiotcentral"
        },
        "mongodb": {
            "connectionId": "[parameters('connections_mongodb_externalid')]",
            "connectionName": "mongodb",
            "id": "/subscriptions/"+subscriptionId+"/providers/Microsoft.Web/locations/francesouth/managedApis/mongodb"
        }
    })

    SETG mongoDB_AzureIotCentralParameterSection:({
        "workflows_"+newLogicAppName+"_name": {
            "defaultValue": newLogicAppName,                    # questa parte è uguale per ogni json
            "type": "String"
        },
        "connections_azureiotcentral_externalid": {
            "defaultValue": "/subscriptions/"+subscriptionId+"/resourceGroups/"+mainResourceGroupName+"/providers/Microsoft.Web/connections/azureiotcentral",
            "type": "String"
        },
        "connections_mongodb_externalid": {
            "defaultValue": "/subscriptions/"+subscriptionId+"/resourceGroups/nuovoResourceGroup/providers/Microsoft.Web/connections/mongodb",
            "type": "String"
        }
    })

}

# get object's "specification" records' values
PROCEDURE global GET_SPECIFICATION_RECORDS
objid:integer
specRecs:reference  # array of specification's records to be passed
{
    CC "Core" GET_CLASS_ID objid:(objid)
    CC "Core" GET_ATTR_ID classid:(classid) attrname:("specification")
    CC "Core" GET_ALL_REC_ATTR_ROW_IDS objid:(objid) attrid:(attrid)

    # insert all the output records in specRecs array
    SET specRecs:({})
    # get specs val
    FOR row in:(rowids) {
        CC "Core" GET_ATTR_VAL objid:(VAL row) attrname:("Value")
        SET blablabla:(aappend(specRecs, val))
    }
}


### ThingsBoard export function
PROCEDURE global THINGSBOARD
    modelID:integer # Source model's id
    path:string # Path where save files
{
    ## 1.
    # Get specifications
    SET convJson:("")
    GET_SPECIFICATIONS platform:("ThingsBoard") specs:convJson

    ## 2.
    # Set application name
    CC "AdoScript" EDITFIELD title:"Enter application name" caption:"Application ~name:" text:"Default"
    IF (ecode = 1) {
        EXIT
    }
    SET path:(path + "\\" + text)
    CC "AdoScript" DIR_CREATE path:(path)

    ## 3.
    # Get the modeltype of the model
    CC "Core" GET_MODEL_MODELTYPE modelid:(modelID)

    IF (modeltype = "IoT Scenario") {
        SET device_profile:({
            "default": 0,
            "defaultQueueName": "",
            "description": "",
            "name": "",
            "profileData": {
                "configuration": {
                    "type": "DEFAULT"
                },
                "provisionConfiguration": {
                    "type": "DISABLED"
                },
                "transportConfiguration": {
                    "deviceAttributesTopic": "v1/devices/me/attributes",
                    "deviceTelemetryTopic": "v1/devices/me/telemetry",
                    "transportPayloadTypeConfiguration": {
                        "transportPayloadType": "JSON"
                    },
                    "type": "MQTT"
                }
            },
            "provisionType": "DISABLED",
            "transportType": "MQTT",
            "type": "DEFAULT"
        })
        SET dashboard:({
            "name": "Dashboard",
            "title": "Dashboard",
            "configuration": {
                "description": "",
                "widgets": map()
            },
            "states": {
                "default": {
                    "name": "Dashboard",
                    "layouts": {
                        "main": {
                            "widgets": {
                            },
                            "gridSettings": {
                                "backgroundColor": "#eeeeee",
                                "columns": 24,
                                "margin": 10,
                                "backgroundSizeMode": "100%"
                            }
                        }
                    }
                }
            },
            "timewindow": {
                "displayValue": "",
                "selectedTab": 0,
                "realtime": {
                    "realtimeType": 0,
                    "interval": 1000,
                    "timewindowMs": 60000,
                    "quickInterval": "CURRENT_DAY"
                },
                "history": {
                    "historyType": 0,
                    "interval": 1000,
                    "timewindowMs": 60000,
                    "fixedTimewindow": {
                        "startTimeMs": 1647250508451,
                        "endTimeMs": 1647336908451
                    },
                    "quickInterval": "CURRENT_DAY"
                },
                "aggregation": {
                    "type": "AVG",
                    "limit": 2500
                }
            }
        })

        SET attributes:(map())
        SET objAttributes:(map())

        # Get all attributes
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("attribute")
        FOR obj in:(objids) {
            CC "Core" GET_CONNECTORS objid:(VAL obj)
            IF (objids != "") {
                CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("name")
                SET attributes[val]:("")
                FOR connector in:(objids) {
                    CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL connector)
                    IF (type(objAttributes[fromobjid]) != "map") {
                        SET objAttributes[fromobjid]:(map())
                    }
                    SET map:(objAttributes[fromobjid])
                    SET key:(val)
                    CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("value")
                    SET map[key]:(val)
                    SET objAttributes[fromobjid]:(map)
                }
            }
        }

        # Get all locations
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("location")
        FOR obj in:(objids) {
            CC "Core" GET_CONNECTORS objid:(VAL obj)
            IF (objids != "") {
                SET attributes["lat"]:("")
                SET attributes["lon"]:("")
                FOR connector in:(objids) {
                    CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL connector)
                    IF (type(objAttributes[fromobjid]) != "map") {
                        SET objAttributes[fromobjid]:(map())
                    }
                    SET map:(objAttributes[fromobjid])
                    CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("lat")
                    SET map["lat"]:(val)
                    CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("lon")
                    SET map["lon"]:(val)
                    SET objAttributes[fromobjid]:(map)
                }
            }
        }

        # Get all device profiles
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("service")
        FOR obj in:(objids) {
            CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("name")
            SET device_profile["name"]:(val)
            CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("description")
            SET device_profile["description"]:(val)
            CC "AdoScript" FWRITE file:(path + "\\device_profile_" + obj + ".json") text:(STR device_profile)
        }

        # Get all devices
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("device")
        SET csv:("")
        SET attributes["name"]:("")
        SET attributes["description"]:("")
        FOR obj in:(objids) {
            SET objMap:(attributes)
            CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("name")
            SET objMap["name"]:(val)
            CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("description")
            SET objMap["description"]:(val)
            CC "Core" GET_CLASS_ID objid:(VAL obj)
            CC "Core" GET_ATTR_ID classid:(classid) attrname:("specification")
            CC "Core" GET_ALL_REC_ATTR_ROW_IDS objid:(VAL obj) attrid:(attrid)
            # Get specification attributes
            FOR row in:(rowids) {
                CC "Core" GET_ATTR_VAL objid:(VAL row) attrname:("Attribute")
                SET key:(val)
                CC "Core" GET_ATTR_VAL objid:(VAL row) attrname:("Value")
                SET objMap[key]:(val)
            }
            # Get other attributes (attribute & location)
            IF (type(objAttributes[VAL obj]) = "map") {
                SET attrs:(objAttributes[VAL obj])
                FOR attr in:(replall(mapKeysList(objAttributes[VAL obj]), "~", " ")) {
                    SET objMap[attr]:(attrs[attr])
                }
            }
            # Add device line on csv
            SET columns:(mapKeysArray(objMap))
            FOR c from:0 to:(objMap.length-1) by:1 {
                IF (c = 0) {
                    SET csv:(csv + "\n" + objMap[columns[c]])
                } ELSE {
                    SET csv:(csv + "," + objMap[columns[c]])
                }
            }
        }
        SET columns:(replall(mapKeysList(objMap), "~", ","))
        SET csv:(columns + csv)
        CC "AdoScript" FWRITE file:(path + "\\devices.csv") text:(csv)

        # Get all systems
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("system")
        SET csv:("")
        FOR obj in:(objids) {
            SET objMap:(attributes)
            CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("name")
            SET objMap["name"]:(val)
            CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("description")
            SET objMap["description"]:(val)
            CC "Core" GET_CLASS_ID objid:(VAL obj)
            CC "Core" GET_ATTR_ID classid:(classid) attrname:("specification")
            CC "Core" GET_ALL_REC_ATTR_ROW_IDS objid:(VAL obj) attrid:(attrid)
            # Get specification attributes
            FOR row in:(rowids) {
                CC "Core" GET_ATTR_VAL objid:(VAL row) attrname:("Attribute")
                SET key:(val)
                CC "Core" GET_ATTR_VAL objid:(VAL row) attrname:("Value")
                SET objMap[key]:(val)
            }
            # Get other attributes (attribute & location)
            IF (type(objAttributes[VAL obj]) = "map") {
                SET attrs:(objAttributes[VAL obj])
                FOR attr in:(replall(mapKeysList(objAttributes[VAL obj]), "~", " ")) {
                    SET objMap[attr]:(attrs[attr])
                }
            }
            # Add asset line on csv
            SET columns:(mapKeysArray(objMap))
            FOR c from:0 to: (objMap.length-1) by:1 {
                IF (c = 0) {
                    SET csv:(csv + "\n" + objMap[columns[c]])
                } ELSE {
                    SET csv:(csv + "," + objMap[columns[c]])
                }
            }
        }
        SET columns:(replall(mapKeysList(objMap), "~", ","))
        SET csv:(columns + csv)
        CC "AdoScript" FWRITE file:(path + "\\assets.csv") text:(csv)

        # Get all widgets
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("widget")
        SET widgetId:(randomDiscreteUniformDist(10000000, 90000000))
        FOR obj in:(objids) {
            SET class:(map())
            CLASS_PSM specs:(convJson) objID:(VAL obj) class:class
            IF (NOT class.empty) {
                SET id:(STR widgetId)
                SET widgetId:(widgetId + 1)
                SET widget:(class["config"])
                SET widget["id"]:(id)
                SET widgetConfig:(widget["config"])
                CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("name")
                SET widgetConfig["title"]:(val)
                CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("description")
                SET widget["description"]:(val)
                SET widget["config"]:(widgetConfig)
                SET configuration:(dashboard["configuration"])
                SET widgets:(configuration["widgets"])
                SET widgets[id]:(widget)
                SET configuration["widgets"]:(widgets)
                SET dashboard["configuration"]:(configuration)
            }
        }
        CC "AdoScript" FWRITE file:(path + "\\dashboard.json") text:(lam_toJson(dashboard))
        
    } ELSIF (modeltype = "IoT Logic") {
        # Set rule chain name
        CC "AdoScript" EDITFIELD title:"Enter rule chain name" caption:"Rule chain ~name:" text:"Default"
        IF (ecode = 1) {
            EXIT
        }
        SET rulechainName:(text)
        SET rulechain:({
            "ruleChain": {
                "additionalInfo": {
                    "description": ""
                },
                "name": rulechainName,
                "type": "CORE"
            },
            "metadata": {
                "nodes": {},
                "connections": {}
            }
        })
        SET nodeIndex:(map())

        # Get all logic nodes
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("node")
        # Add nodes to rule chain file
        FOR obj in:(objids) {
            SET class:(map())
            CLASS_PSM specs:(convJson) objID:(VAL obj) class:class
            IF (NOT class.empty) {
                SET metadata:(rulechain["metadata"])
                SET nodes:(metadata["nodes"])
                SET node:(map())
                SET info:(map())
                CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("name")
                SET node["name"]:(val)
                CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("description")
                SET info["description"]:(val)
                CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:"Position"
                LEO parse:(val) get-tmm-value:x:"x" get-tmm-value:y:"y"
                SET info["layoutX"]:((CMS x)*50+100)
                SET info["layoutY"]:((CMS y)*50)
                SET node["additionalInfo"]:(info)
                SET node["type"]:(class["config"]["type"])
                SET n:(aappend(nodes, node))
                SET metadata["nodes"]:(nodes)
                SET rulechain["metadata"]:(metadata)
                SET nodeIndex[VAL obj]:(nodeIndex.length)
            }
        }

        # Get all logic connectors
        CC "Core" GET_ALL_CONNECTORS modelid:(modelID)
        # Add connectors to rule chain file
        FOR obj in:(objids) {
            CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("psm_type")
            CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL obj)
            IF (val != "" AND type(nodeIndex[toobjid]) != "undefined" AND type(nodeIndex[fromobjid]) != "undefined") {
                SET connection:(map())
                SET connection["type"]:(val)
                SET connection["toIndex"]:(nodeIndex[toobjid])
                SET connection["fromIndex"]:(nodeIndex[fromobjid])
                SET metadata:(rulechain["metadata"])
                SET connections:(metadata["connections"])
                SET n:(aappend(connections, connection))
                SET metadata["connections"]:(connections)
                SET rulechain["metadata"]:(metadata)
            }
        }

        SET json:(lam_toJson(rulechain))
        CC "AdoScript" FWRITE file:(path + "\\" + rulechainName + ".json") text:(lam_toJson(rulechain))
    }
}


### Losant export function
PROCEDURE global LOSANT
    modelID:integer # Source model's id
    path:string # Path where save files
{
    ## 1.
    # Get specifications
    SET convJson:("")
    GET_SPECIFICATIONS platform:("Losant") specs:convJson

    ## 2.
    # Set application name
    CC "AdoScript" EDITFIELD title:"Enter application name" caption:"Application ~name:" text:"Default"
    IF (ecode = 1) {
        EXIT
    }
    SET applicationName:(text)

    ## 3.
    # Get the modeltype of the model
    CC "Core" GET_MODEL_MODELTYPE modelid:(modelID)

    IF (modeltype = "IoT Scenario") {
        SET applicationId:("~exportplaceholderid-application-demo-0~")
        SET application:({
            "resourceType": "Application",
            "resources": {
                {
                    "blobUrlTTL": 86400,
                    "description": "",
                    "filesPath": "./files",
                    "globals": {},
                    "id": applicationId,
                    "name": "",
                    "readmePath": "./README.md"
                }
            },
            "version": 1
        })
        SET dashboard:({
            "resourceType": "Dashboard",
            "resources": {
                {
                    "blocks": {},
                    "contextConfiguration": {},
                    "defaultTheme": "light",
                    "description": "",
                    "id": "~exportplaceholderid-dashboard-dashboard-0~",
                    "name": "Dashboard",
                    "refreshRate": 60
                }
            },
            "version": 1
        })
        SET devices:({
            "resourceType": "DeviceTree",
            "resources": {},
            "version": 1
        })

        SET appDetails:(application["resources"])
        SET appResources:(appDetails[0])
        SET appResources["name"]:(applicationName)
        SET appResources["description"]:(applicationName + " application")
        SET appDetails[0]:(appResources)
        SET application["resources"]:(appDetails)

        # Get all systems and devices
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("system")
        SET systemids:(objids)
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("device")
        SET systemids:(systemids + " " + objids)
        SET struct:(map())
        SET resources:({})
        FOR systemid in:(systemids) {
            SET check:(0)
            CC "Core" GET_CONNECTORS objid:(VAL systemid) in
            FOR connid in:(objids) {
                CC "Core" GET_CLASS_ID relation objid:(VAL connid)
                CC "Core" GET_CLASS_NAME classid:(classid)
                IF (classname = "subsystem" OR classname = "hasDevice") {
                    SET check:(1)
                }
            }
            IF (check = 0) {
                LOSANT_DEVICES objID:(VAL systemid) struct:struct
                IF (struct.empty = 0) {
                    SET n:(aappend(resources, struct))
                }
            }
        }
        SET devices["resources"]:(resources)

        # Get all widgets
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("widget")
        SET dashboardResources:(dashboard["resources"])
        SET resources:(dashboardResources[0])
        SET height:(0)
        FOR widgetid in:(objids) {
            SET class:(map())
            CLASS_PSM specs:(convJson) objID:(VAL widgetid) class:class
            IF (NOT class.empty) {
                # Get widget's information
                SET widgets:(resources["blocks"])
                SET widget:(class["config"])
                SET widget["id"]:(widgetid)
                SET widget["applicationId"]:(applicationId)
                SET widget["startY"]:(height)
                CC "Core" GET_ATTR_VAL objid:(VAL widgetid) attrname:("name")
                SET widget["title"]:(val)
                SET n:(aappend(widgets, widget))
                SET resources["blocks"]:(widgets)
                SET dashboardResources[0]:(resources)
                SET dashboard["resources"]:(dashboardResources)
                SET height:(height + widget["height"])
            }
        }

        # Create application's files
        SET path:(path + "\\" + applicationName)
        CC "AdoScript" DIR_CREATE path:(path)
        CC "AdoScript" FWRITE file:(path + "\\application.json") text:(lam_toJson(application))
        CC "AdoScript" FWRITE file:(path + "\\devices.json") text:(lam_toJson(devices))
        SET path:(path + "\\dashboards")
        CC "AdoScript" DIR_CREATE path:(path)
        CC "AdoScript" FWRITE file:(path + "\\dashboard.json") text:(lam_toJson(dashboard))
    } ELSIF (modeltype = "IoT Logic") {
        # Set workflow name
        CC "AdoScript" EDITFIELD title:"Enter workflow name" caption:"Workflow ~name:" text:"Default"
        IF (ecode = 1) {
            EXIT
        }
        SET workflowName:(text)
        SET workflow:({
            "resourceType": "Flow",
            "resources": {
                {
                    "description": "",
                    "flowClass": "cloud",
                    "globals": {},
                    "id": "~exportplaceholderid-flow-workflow-0~",
                    "name": workflowName,
                    "nodes": {},
                    "triggers": {}
                }
            },
            "version": 1
        })
        
        # Get all logic nodes
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("node")
        SET workflowResources:(workflow["resources"])
        SET resources:(workflowResources[0])
        # Add nodes to rule chain file
        FOR obj in:(objids) {
            SET class:(map())
            CLASS_PSM specs:(convJson) objID:(VAL obj) class:class
            IF (NOT class.empty) {
                # Get node's information
                SET triggers:(resources["triggers"])
                SET nodes:(resources["nodes"])
                SET node:(class["config"])
                SET meta:(node["meta"])
                CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("name")
                SET meta["label"]:(val)
                CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("description")
                SET meta["description"]:(val)
                CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("Position")
                LEO parse:(val) get-tmm-value:x:"x" get-tmm-value:y:"y"
                SET meta["x"]:((CMS x)*40)
                SET meta["y"]:((CMS y)*50)
                
                # Get node's out connectors
                IF (type(class["output"]) = "array") {
                    SET outputs:(map())
                    FOR i from:0 to:(class["output"].length-1) {
                        SET outputs[class["output"][i]]:({}) 
                    }
                    CC "Core" GET_CONNECTORS objid:(VAL obj) out
                    SET connids:(objids)
                    FOR connid in:(connids) {
                        CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL connid)
                        CC "Core" GET_ATTR_VAL objid:(VAL connid) attrname:("psm_type")
                        SET conntype:(val)
                        SET outputClass:("")
                        CLASS_PSM specs:(convJson) objID:(toobjid) class:outputClass
                        IF (conntype != "" AND NOT outputClass.empty) {
                            SET output:(outputs[conntype])
                            SET n:(aappend(output, STR toobjid))
                            SET outputs[conntype]:(output)
                        }
                    }
                    SET outputIds:(node["outputIds"])
                    SET outKeys:(mapKeysArray(outputs))
                    FOR i from:0 to:(outKeys.length-1) {
                        SET n:(aappend(outputIds, outputs[outKeys[i]]))
                    }
                    SET node["outputIds"]:(outputIds)
                }
                IF (node["meta"]["category"] = "trigger") {
                    SET meta["uiId"]:(obj)
                    SET node["meta"]:(meta)
                    SET n:(aappend(triggers, node))
                    SET resources["triggers"]:(triggers)
                } ELSE {
                    SET node["id"]:(obj)
                    SET node["meta"]:(meta)
                    SET n:(aappend(nodes, node))
                    SET resources["nodes"]:(nodes)
                }
            }
            SET workflowResources[0]:(resources)
            SET workflow["resources"]:(workflowResources)
        }

        SET path:(path + "\\" + applicationName)
        CC "AdoScript" DIR_CREATE path:(path)
        SET path:(path + "\\workflows")
        CC "AdoScript" DIR_CREATE path:(path)
        CC "AdoScript" FWRITE file:(path + "\\" + workflowName + ".json") text:(lam_toJson(workflow))
    }
}

PROCEDURE global LOSANT_DEVICES 
    objID:integer
    struct:reference
{
    SETL device:(map())
    SETL children:({})
    SETL attributes:({})
    SETL tags:({})
    SETL attributeTags:(map())
    CC "Core" GET_CLASS_ID objid:(objID)
    CC "Core" GET_CLASS_NAME classid:(classid)

    IF (classname = "system") {
        CC "Core" GET_ATTR_VAL objid:(objID) attrname:("name")
        SETL name:(val)
        IF (name != "") {
            SETL device["id"]:("~exportplaceholderid-system-name-" + STR objID + "~")
            SETL device["name"]:(name)
            SETL device["deviceClass"]:("system")
            CC "Core" GET_CONNECTORS objid:(objID) out
            SETL connids:(objids)
            FOR connid in:(connids) {
                SETL obj:(map())
                CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL connid)
                LOSANT_DEVICES objID:(toobjid) struct:obj
                IF (obj.empty = 0) {
                    CC "Core" GET_CLASS_ID relation objid:(VAL connid)
                    CC "Core" GET_CLASS_NAME classid:(classid)
                    IF (classname = "hasDevice" OR classname = "subsystem") {
                        SET n:(aappend(children, obj))
                    } ELSIF (classname = "hasAttribute" OR classname = "hasLocation" OR classname = "hasService") {
                        SET n:(aappend(attributes, obj))
                    }
                }
            }
            SETL device["children"]:(children)
            SETL device["attributes"]:(attributes)
            SETL device["tags"]:(tags)
        }
    } ELSIF (classname = "device") {
        CC "Core" GET_ATTR_VAL objid:(objID) attrname:("name")
        SETL name:(val)
        CC "Core" GET_ATTR_VAL objid:(objID) attrname:("psm_type")
        SETL deviceClass:(val)
        IF (name != "" AND deviceClass != "") {
            SETL device["id"]:("~exportplaceholderid-device-name-" + STR objID + "~")
            SETL device["name"]:(name)
            SETL device["deviceClass"]:(deviceClass)
            CC "Core" GET_CONNECTORS objid:(objID) out
            SETL connids:(objids)
            FOR connid in:(connids) {
                SETL obj:(map())
                CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL connid)
                LOSANT_DEVICES objID:(toobjid) struct:obj
                IF (obj.empty = 0) {
                    CC "Core" GET_CLASS_ID relation objid:(VAL connid)
                    CC "Core" GET_CLASS_NAME classid:(classid)
                    IF (classname = "hasAttribute" OR classname = "hasLocation" OR classname = "hasService") {
                        SET n:(aappend(attributes, obj))
                    }
                }
            }
            SETL device["children"]:(children)
            SETL device["attributes"]:(attributes)
            SETL device["tags"]:(tags)
        }
    } ELSIF (classname = "attribute") {
        CC "Core" GET_ATTR_VAL objid:(objID) attrname:("name")
        SETL attrName:(val)
        SETL attrType:("")
        CC "Core" GET_ATTR_VAL objid:(objID) attrname:("type")
        IF (val = "boolean") {
            SET attrType:("boolean")
        } ELSIF (val = "string") {
            SET attrType:("string")
        } ELSIF (val = "numeric") {
            SET attrType:("number")
        }
        IF (attrName != "" AND attrType != "") {
            SETL device["name"]:(attrName)
            SETL device["dataType"]:(attrType)
            SETL device["attributeTags"]:(attributeTags)
        }
    } ELSIF (classname = "location") {
        CC "Core" GET_ATTR_VAL objid:(objID) attrname:("name")
        SETL device["name"]:("position")
        SETL device["dataType"]:("gps")
        SETL device["attributeTags"]:(attributeTags)
    }

    SETL struct:(device)
}